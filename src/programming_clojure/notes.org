#+TITLE: Programming Clojure

* Introduction

Notes from programming clojure book. It will be devided into section
chapter wise. If there is any content that do not fit any chatper, or
random things, it will be put under section called *General*

* General
**  Forms
Forms are unit of code or data that is treated as single enity by the
Clojure compiler. Forms can be expressions, macros, data structures
etc.

Clojure code is made up of nested forms. The compiler evaluates these
forms according to some rules

** Functional programming
- Properties of functional programming:
  - Functions are first class object. i.e, functions can be created at
    runtime, passed around and returned.
  - Data is immutable
  - Functions are pure

** Clojure features
- Lisp code is homoiconoic: i.e, lisp code is lisp data.
- Clojure generalizes Lisp's physical list into an abstraction called
  sequence.
- Clojure protects mutable state via Software Transactional Memory. STM
  is a higher level approach to thread safety.
- You can consdier clojure ref as thread safe, in memory database of its
  own. For eg:
- Clojure codes are packaged into libraries and each libraries belong
  to certain namespace.
- Clojure sets can also be function that tests membersnhips

  #+BEGIN_SRC clojure
    ;; ref function creates transactionally protected reference.
    (def accounts (ref #{}))
    (defrecord Account [id balance])

    ;; Updating the state
    (dosync
     (alter accounts conj (->Account "CLJ" 1000.00)))
    ;; dosync causes the update to accounts to execute inside a
    ;; transaction which makes it thread safe

    ;; refer to the current namespace using
    (ns-name *ns*)

    ;; quoting
    ;; it means not to find the corresponding var and evaluate the value,
    ;; just use it as a data

    ;; refer
    (ns user2)
    (def hello "Hello")
    (ns user)
    (refer 'user2)
    (refer 'user2 :only ['hello])
    hello ;; "hello"
    ;; you don't need to use fully qualified name
    ;; :exclude and :rename are also available
    ;; NOTE: rename takes a map not a vector

    ;; instead of
    (require 'clojure/core)
    ;; we can use
    (clojure.core/refer-clojure)

  #+END_SRC

** Java
Running programs on Java Virtual Machine (JVM) requires assembling a
classpath that contains all of the code required to run your program,
which includes Clojure itself, your code, and any Java or Clojure
dependencies needed by your code.

** Repl
- Special Variables: The result of evaluating three most recent
  expressions are stored in special variables *1, *2 and *3.
- In the repl, if an exception is thrown, the details are often not
  shown due to brevity reason. But if you still want to see the
  Exception, you can use the special variable *e. Or you can just print
  the stack trace using (pst) function

** Code samples
#+BEGIN_SRC clojure
  ;; Create a record
  (defrecord Person [first-name last-name])
  (def foo (->Person "Saurav" "Sp"))
  (:first-name foo)

  ;; Difference between doto and threading macro .. in interops
  (doto "Hello" (.this)(.that))
  ;; this will return the first object
  ;; "Hello" with the all the side effect that has taken place
  ;; on that object.
  (.. "Hello" getClass getOtherclas)
  ;; This will return value of the last function.

  ;; for list to be evaluated as data
  (quote (1 2 3))
  ;; or
  '( 1 2 3)
#+END_SRC

** namespace
If you want to swtich to other namespace use in-ns function
By default java.lang package is automatically available.
To make clojure.core package avaiable
Execute this code
(clojure.core/user 'clojure.core)


* Exploring Clojure
- Clojure's runtime evaluates lists as function calls.
- Symbols are used to name things.
  - It can name funtions like str, concat
  - Operators like + (this is actually a function)
  - Java classes like java.lang.String
  - Namespaces like clojure.core
- Vector is sequential indexed collection.
- Lists are sequential collection stored as linked list.
- Sets are a good choice for fast addition and removal of element
- True is ture, false is false and nil is false.
- Other than false and nil, everything else evaluates to true
- Empty list is not false in clojure
- Zero (0) is not false in clojrue
- (nil? false) -> false
- (false? nil) -> false ;; false? check if the value is exactly false
  or not
** Predicate
A function that returns true or false
** defn
#+BEGIN_SRC clojure
  (defn name doc-string? attr-map? [params*] prepost-map? body)
#+END_SRC
- attr-map? -- associates metadata with function's var
- prepost-map? -- used to define preconditions and postconditions that are
  automatically checked on invocation
** Variable arity
- User ampersand at the end of the name of the variable
- Clojure binds the name after the ampersand to a sequence of all
  remaining params
** Vars, Bindings, and Namespaces
- A namespace is a collection of names(symbols) that refers to vars.
- Each var is bound to value

*** Vars
- When you define an object with *def* or *defn*, that object is
  stored in clojure var

  For example, \\
  #+BEGIN_SRC  clojure
  (def foo 10) ;; -> #'user/foo
  #+END_SRC
  The symbol #'user/foo refers to a var that is bound to a value 10 \\
  Clojure evaluates this symbol by returning the value associated with
  the var it refers to.
- The initial value of var is called *root-binding*. Sometimes it's
  useful to have *thread-local binding* for vars.
- You can use var to return the var bound to user/foo:
    #+BEGIN_SRC  clojure
  (var foo) ;; #'user/foo
  #+END_SRC
- There is a reader macro for the above code
- #'foo - equavlent - (var foor)
- var can have metadata
- var can be dynamically rebound on a per-thread basis

*** Bindings
- Vars a re bound to name. That is also a binding. For example,
  binding in let

*** Difference between var and binding

A binding is a name for a value within the scope of a function or let:
#+BEGIN_SRC clojure
(fn [x] x)
(let [x 1] x)
#+END_SRC
In both examples, x is a (lexical) binding. The binding is immutable,
you can't modify it. So it's just a name bound to a value and you can
refer to this name later on in the same scope.

A var however is a globally defined named mutable location.

#+BEGIN_SRC clojure
(def x 1)
(alter-var-root #'x inc) ;; x becomes 2
(defn foo [] 1) ;; foo is a var bound to a function
(foo) ;; returns 1
#+END_SRC
In a REPL you constantly re-define vars, e.g. if we want to modify the
function foo, we just evaluate again:

#+BEGIN_SRC clojure
(defn foo [] 2) ;; foo is the same var, but now bound to a new function
(foo) ;; now returns 2
#+END_SRC

A dynamic binding only refers to dynamic vars, which are vars, and can
be mutated using the binding macro. This name might confuse you, since
it has nothing to do with the bindings in fn or let.

[[https://clojure.org/reference/vars][Clojure - Vars and the Global Environment]]

*** Storing object with *def* or *defn*
*(def great-books ["East of Eden" "The Glass Bead Game"])* \\
This is what clojure does when we evaluate the above code. And this
process is called *internting a var*
- Update the current namespaceâ€™s map with the association between
  great-books and the var.
- Find a free storage shelf.
- Store ["East of Eden" "The Glass Bead Game"] on the shelf.
- Write the address of the shelf on the var.
- Return the var (in this case, #'user/great-books).

*** Ineteract with namespace map of interned var
- (ns-interns *ns*) ;; returns all the interned vars in the current
  namespace
- (ns-map *ns*) ;; this returns the full map that the namespace uses
  to lookup for vars


*** Root binding
Root binding refers to the initial global binding of a var when it was
first initialized with *defn* or *def*

** Destructuring
*** Map destructuring
Already familiar
*** Vector desctructuring
#+BEGIN_SRC clojure
    (let [[x y] [ 1 2 3]] [x y]) ;; -> [ 1, 2]

    ;; if you want to skip element at start of a colleciton, here's what
    ;; you could do
    (let [[ _ _ z] [ 1 2 3]]
      z)
    ;; -> 3
    ;; underscore can be used for saying something that goes along the
    ;; line like this
    ;; I don't care about your binding

    ;; also possible to simultaneously bind both collection and element

  (let [[x y :as coordinates] [1 2]]
      coordinates)
  ;; -> [1 2]
#+END_SRC

** Import java classes
#+BEGIN_SRC clojure
  ;; (import '(package Class+))
  (import '(java.io InputStream File))
#+END_SRC

** Adding metadata
#+BEGIN_SRC clojure
  (defn ^{:tag String} should [s] (clojure.string/upper-case s))
  ;; you can also add metadata to function args
  (defn ^{:tag String} should
    [^{:tag String} s] (clojure.string/upper-case s))
  ;; because tag metadata is so common, you can also use the shortform
  ;; ^Classname, which expands to ^{:tag Classname}
  (defn ^String should [^String s] (clojure.string/upper-case s))
#+END_SRC
