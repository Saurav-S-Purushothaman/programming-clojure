#+TITLE: Programming Clojure

* Introduction

Notes from programming clojure book. It will be devided into section
chapter wise. If there is any content that do not fit any chatper, or
random things, it will be put under section called *General*

* General
**  Forms
Forms are unit of code or data that is treated as single enity by the
Clojure compiler. Forms can be expressions, macros, data structures
etc.

Clojure code is made up of nested forms. The compiler evaluates these
forms according to some rules

** Functional programming
- Properties of functional programming:
  - Functions are first class object. i.e, functions can be created at
    runtime, passed around and returned.
  - Data is immutable
  - Functions are pure

** Clojure features
- Lisp code is homoiconoic: i.e, lisp code is lisp data.
- Clojure generalizes Lisp's physical list into an abstraction called
  sequence.
- Clojure protects mutable state via Software Transactional Memory. STM
  is a higher level approach to thread safety.
- You can consdier clojure ref as thread safe, in memory database of its
  own. For eg:
- Clojure codes are packaged into libraries and each libraries belong
  to certain namespace.

  #+BEGIN_SRC clojure
    ;; ref function creates transactionally protected reference.
    (def accounts (ref #{}))
    (defrecord Account [id balance])

    ;; Updating the state
    (dosync
     (alter accounts conj (->Account "CLJ" 1000.00)))
    ;; dosync causes the update to accounts to execute inside a
    ;; transaction which makes it thread safe
  #+END_SRC

** Java
Running programs on Java Virtual Machine (JVM) requires assembling a
classpath that contains all of the code required to run your program,
which includes Clojure itself, your code, and any Java or Clojure
dependencies needed by your code.

** Repl
- Special Variables: The result of evaluating three most recent
  expressions are stored in special variables *1, *2 and *3.
- In the repl, if an exception is thrown, the details are often not
  shown due to brevity reason. But if you still want to see the
  Exception, you can use the special variable *e. Or you can just print
  the stack trace using (pst) function

* Code samples
#+BEGIN_SRC clojure
  ;; Create a record
  (defrecord Person [first-name last-name])
  (def foo (->Person "Saurav" "Sp"))
  (:first-name foo)

  ;; Difference between doto and threading macro .. in interops
  (doto "Hello" (.this)(.that))
  ;; this will return the first object
  ;; "Hello" with the all the side effect that has taken place
  ;; on that object.
  (.. "Hello" getClass getOtherclas)
  ;; This will return value of the last function.

  ;; for list to be evaluated as data
  (quote (1 2 3))
  ;; or
  '( 1 2 3)
#+END_SRC


* Exploring Clojure
- Clojure's runtime evaluates lists as function calls.
- Symbols are used to name things.
  - It can name funtions like str, concat
  - Operators like + (this is actually a function)
  - Java classes like java.lang.String
  - Namespaces like clojure.core
- Vector is sequential indexed collection.
- Lists are sequential collection stored as linked list.
- Sets are a good choice for fast addition and removal of element
